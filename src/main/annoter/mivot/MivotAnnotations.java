package main.annoter.mivot;

import java.util.*;

import main.annoter.dm.MangoInstance;
import main.annoter.dm.Property;
import main.annoter.meta.Glossary;
import main.annoter.meta.MappingCache;
import main.annoter.meta.UtypeDecoder;
import main.annoter.utils.XmlUtils;

/**
 * Collect all annotation components and put them together to build the
 * annotation block (as a String)
 */
public class MivotAnnotations {
	/** Map of model prefix -> model VODML URL (used to build <MODEL> entries). */
	private Map<String, String> models;

	/** Mapping/report status: true = OK, false = FAILED. */
	private boolean reportStatus;

	/** Human-readable report message included in the <REPORT> element. */
	private String reportMessage;

	/**
	 * Collected GLOBALS XML fragments (each entry is a fragment to include inside
	 * <GLOBALS>).
	 */
	private List<String> globals;

	/**
	 * Collected TEMPLATES XML fragments (each entry is a fragment to include inside
	 * <TEMPLATES>).
	 */
	private List<String> templates;

	/** Optional table id referenced by <TEMPLATES tableref="...">. */
	private String templatesId;

	/**
	 * Collected DMIDs used by added instances (keeps track of IDs to avoid
	 * duplicates).
	 */
	private List<String> dmids;

	/**
	 * Final assembled MIVOT block as a pretty-printed XML string (built by
	 * buildMivotBlock()).
	 */
	public String mivotBlock;

	/**
	 * Create a new, empty MivotAnnotations collector.
	 *
	 * Initializes internal collections and sets a default report status and
	 * message.
	 */
	public MivotAnnotations() {
		this.models = new LinkedHashMap<>();
		this.reportStatus = true;
		this.reportMessage = "Generated by the VOLLT Mivot extension";
		this.globals = new ArrayList<>();
		this.templates = new ArrayList<>();
		this.templatesId = "";
		this.dmids = new ArrayList<>();
		this.mivotBlock = "";
	}

	/**
	 * Return the last built MIVOT block as a pretty-printed XML string.
	 *
	 * @return assembled MIVOT XML block (may be empty string if buildMivotBlock has
	 *         not been called or if the report indicates failure)
	 */
	public String getMivotBlock() {
		return this.mivotBlock;
	}

	/**
	 * Check whether a DMID has already been recorded in this collector.
	 *
	 * @param dmid the DMID to check
	 * @return true if the DMID is present, false otherwise
	 */
	public boolean containsDmid(String dmid) {
		return this.dmids.contains(dmid);
	}

	/**
	 * Return an unmodifiable view of the collected DMIDs.
	 *
	 * @return a List of DMIDs (modifiable copy of the internal list is recommended
	 *         by caller)
	 */
	public List<String> getDmids() {
		return this.dmids;
	}

	/**
	 * Record a DMID if not already present.
	 *
	 * @param dmid the DMID to add
	 */
	public void addDmid(String dmid) {
		if (!this.dmids.contains(dmid)) {
			this.dmids.add(dmid);
		}
	}

	/**
	 * Build the <REPORT> XML element using the current status and message.
	 *
	 * @return XML fragment for the report element (no surrounding newlines)
	 */
	private String getReport() {
		String status = reportStatus ? "OK" : "FAILED";
		return "<REPORT status=\"" + status + "\">" + reportMessage + "</REPORT>";
	}

	/**
	 * Build the concatenated <MODEL/> entries from the models map.
	 *
	 * @return XML fragments for each model entry (may be empty if no models)
	 */
	private String getModels() {
		StringBuilder sb = new StringBuilder();
		for (Map.Entry<String, String> entry : models.entrySet()) {
			if (entry.getValue() != null && !entry.getValue().isEmpty()) {
				sb.append("<MODEL name=\"").append(entry.getKey()).append("\" url=\"").append(entry.getValue())
						.append("\" />\n");
			} else {
				sb.append("<MODEL name=\"").append(entry.getKey()).append("\" />\n");
			}
		}
		return sb.toString();
	}

	/**
	 * Wrap the collected globals fragments in a <GLOBALS> container.
	 *
	 * @return the full <GLOBALS> XML block (may contain only the open/close tags if
	 *         none)
	 */
	private String getGlobals() {
		StringBuilder sb = new StringBuilder("<GLOBALS>\n");
		for (String g : globals) {
			sb.append(g).append("\n");
		}
		sb.append("</GLOBALS>\n");
		return sb.toString();
	}

	/**
	 * Wrap the collected templates fragments in a <TEMPLATES> container and add a
	 * tableref attribute when templatesId is set.
	 *
	 * @return the full <TEMPLATES> XML block, or an empty string when no templates
	 */
	private String getTemplates() {
		if (templates.isEmpty())
			return "";

		StringBuilder sb = new StringBuilder();
		if (templatesId != null && !templatesId.isEmpty()) {
			sb.append("<TEMPLATES tableref=\"").append(templatesId).append("\">\n");
		} else {
			sb.append("<TEMPLATES>\n");
		}

		for (String t : templates) {
			sb.append(t).append("\n");
		}
		sb.append("</TEMPLATES>\n");
		return sb.toString();
	}

	/**
	 * Build a complete MIVOT blocks from all element stored in the current instance
	 * 
	 * @param templatesId ID of the mapped table (optional) The first table is taken
	 *                    if null
	 * @throws Exception
	 */
	public void buildMivotBlock(String templatesId) throws Exception {
		if (templatesId != null) {
			this.templatesId = templatesId;
		}

		StringBuilder sb = new StringBuilder();
		sb.append("<VODML xmlns=\"http://www.ivoa.net/xml/mivot\">\n");
		sb.append(getReport()).append("\n");
		sb.append(getModels()).append("\n");
		sb.append(getGlobals()).append("\n");
		sb.append(getTemplates()).append("\n");
		sb.append("</VODML>");

		this.mivotBlock = XmlUtils.prettyString(sb.toString()).replaceAll("\n\\s*\n", "\n");
	}

	/**
	 * Add a MIVOT element in TEMPLATES
	 * 
	 * @param instance MivotInstance or string serialization of an instance
	 * @throws Exception
	 */
	public void addTemplates(Object instance) throws Exception {
		if (instance instanceof MivotInstance) {
			MivotInstance mi = (MivotInstance) instance;
			templates.add(mi.xmlString());
			if (mi.getDmid() != null)
				dmids.add(mi.getDmid());
		} else if (instance instanceof String) {
			templates.add((String) instance);
		} else {
			throw new Exception("Invalid type for templates instance: " + instance.getClass());
		}
	}

	/**
	 * Add a MIVOT element in GLOBALS
	 * 
	 * @param instance MivotInstance or string serialization of an instance
	 * @throws Exception
	 */
	public void addGlobals(Object instance) throws Exception {
		if (instance instanceof MivotInstance) {
			MivotInstance mi = (MivotInstance) instance;
			globals.add(mi.xmlString());
			if (mi.getDmid() != null)
				dmids.add(mi.getDmid());
		} else if (instance instanceof String) {
			globals.add((String) instance);
		} else {
			throw new Exception("Invalid type for globals instance");
		}
	}

	/**
	 * Add a <MODEL> element
	 * 
	 * @param name model name, this used as VODML prefix
	 * @param url  points on the model VODML file
	 */
	public void addModel(String name, String url) {
		models.put(name, url);
	}

	/**
	 * Set the mapping/report status and message.
	 *
	 * @param status  mapping status (true = OK, false = FAILED)
	 * @param message human-readable report message (free text)
	 *
	 *                If status is false, GLOBALS and TEMPLATES collections are
	 *                cleared to avoid publishing invalid mappings. Consider adding
	 *                logging here to record the failure or the reason for the
	 *                report message.
	 */
	public void setReport(boolean status, String message) {
		this.reportStatus = status;
		this.reportMessage = message;
		if (!status) {
			globals.clear();
			templates.clear();
		}
	}

	public static String mapMango(String table, List<String> selectedColumns) {
		return mapMango(Arrays.asList(table), selectedColumns);
	}

	public static String mapMango(List<String> tables, List<String> selectedColumns) {
		MappingCache MAPPING_CACHE = MappingCache.getCache();
		// Build the annotations
		MivotAnnotations mivotAnnotation = new MivotAnnotations();

		// Build the MANGO instance with the column used as identifier

		MangoInstance mi;
		try {
			String utypeMappedColumn = null;
			for (String table : tables) {
				utypeMappedColumn = MAPPING_CACHE.getUtypeMappedColumn(table, "mango:MangoObject.identifier",
						selectedColumns);
				if (utypeMappedColumn != null) {
					break;
				}
			}
			mi = new MangoInstance(utypeMappedColumn);
			FrameFactory frameFactory = FrameFactory.getInstance();
			frameFactory.reset();
			for (String supportedProperty : Glossary.SUPPORTED_PROPERTIES) {
				// Look for mapping rules for the property in the current table

				for (String table : tables) {

					Map<String, List<UtypeDecoder>> propertyMapping = MAPPING_CACHE.getTableMapping(table,
							"mango:" + supportedProperty, selectedColumns);
					for (String key : propertyMapping.keySet()) {
						List<FrameHolder> frameHolders = new ArrayList<>();
						System.out.println(supportedProperty + " mapping: " + key);
						List<UtypeDecoder> utds = propertyMapping.get(key);
						for (String cs : utds.get(0).getFrames()) {
							System.out.println(" Creating frame for CS: " + cs);
							FrameHolder fh = frameFactory.createFrame(cs);
							frameHolders.add(fh);
							mivotAnnotation.addModel(fh.systemClass, frameFactory.models.get(fh.systemClass));

							mivotAnnotation.addGlobals(fh.frameXml);
						}
						Property property = (Property) Property.getInstance(supportedProperty, utds, table,
								frameHolders);
						mi.addMangoProperties(property);
					}
				}
			}

			mivotAnnotation.addModel(Glossary.ModelPrefix.IVOA, Glossary.VodmlUrl.IVOA);
			mivotAnnotation.addModel(Glossary.ModelPrefix.MANGO, Glossary.VodmlUrl.MANGO);
			for (String model : FrameFactory.getInstance().models.keySet()) {
				mivotAnnotation.addModel(model, FrameFactory.getInstance().models.get(model));
			}

			mivotAnnotation.addTemplates(mi);

			mivotAnnotation.buildMivotBlock("");
			mivotAnnotation.setReport(true, "Annotated by vollt-mivot-extension");
		} catch (Exception exception) {
			exception.printStackTrace();
			mivotAnnotation.setReport(false, "Annotation failure: " + exception);
		}
		return mivotAnnotation.mivotBlock;
	}
}
