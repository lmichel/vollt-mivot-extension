package main.annoter.mivot;

import java.util.*;

import main.annoter.cache.Cache;
import main.annoter.cache.MappingCache;
import main.annoter.cache.SessionCache;
import main.annoter.dm.MangoInstance;
import main.annoter.dm.Property;
import main.annoter.meta.UtypeDecoder;
import main.annoter.utils.XmlUtils;
import main.annoter.meta.Glossary;

/**
 * Collector for building a MIVOT annotation block.
 *
 * Responsibilities:
 * - Collect MODEL, GLOBALS and TEMPLATES fragments produced during mapping.
 * - Track generated DMIDs to avoid duplicates when assembling fragments.
 * - Build a final pretty-printed <VODML> MIVOT block via {@link #buildMivotBlock(String)}.
 *
 * Notes:
 * - This class is a simple in-memory assembler; it does not persist state.
 * - The mapping/report status controls whether collected fragments are kept
 *   or cleared when a mapping failure is detected.
 */
public class MivotAnnotations {
	/** Map of model prefix -> model VODML URL (used to build <MODEL> entries). */
	private Map<String, String> models;

	/** Mapping/report status: true = OK, false = FAILED. */
	private boolean reportStatus;

	/** Human-readable report message included in the <REPORT> element. */
	private String reportMessage;

	/**
	 * Collected GLOBALS XML fragments (each entry is a fragment to include inside
	 * <GLOBALS>).
	 */
	private List<String> globals;

	/**
	 * Collected TEMPLATES XML fragments (each entry is a fragment to include inside
	 * <TEMPLATES>).
	 */
	private List<String> templates;

	/** Optional table id referenced by <TEMPLATES tableref="...">. */
	private String templatesId;

	/**
	 * Collected DMIDs used by added instances (keeps track of IDs to avoid
	 * duplicates).
	 */
	private List<String> dmids;

	/**
	 * Final assembled MIVOT block as a pretty-printed XML string (built by
	 * {@link #buildMivotBlock(String)}).
	 */
	public String mivotBlock;

	public SessionCache sessionCache;
	
	/**
	 * Create a new, empty MivotAnnotations collector.
	 *
	 * Initializes internal collections and sets a default report status and
	 * message.
	 */
	public MivotAnnotations() {
		this.models = new LinkedHashMap<>();
		this.reportStatus = true;
		this.reportMessage = "Generated by the VOLLT Mivot extension";
		this.globals = new ArrayList<>();
		this.templates = new ArrayList<>();
		this.templatesId = "";
		this.dmids = new ArrayList<>();
		this.mivotBlock = "";
		this.sessionCache = new SessionCache();
	}

	/**
	 * Return the last built MIVOT block as a pretty-printed XML string.
	 *
	 * @return assembled MIVOT XML block (may be empty string if buildMivotBlock has
	 *         not been called or if the report indicates failure)
	 */
	public String getMivotBlock() {
		return this.mivotBlock;
	}

	/**
	 * Check whether a DMID has already been recorded in this collector.
	 *
	 * @param dmid the DMID to check
	 * @return true if the DMID is present, false otherwise
	 */
	public boolean containsDmid(String dmid) {
		return this.dmids.contains(dmid);
	}

	/**
	 * Return the collected DMIDs.
	 *
	 * Note: this returns the internal list reference. Callers that need to
	 * mutate the returned list should create a defensive copy.
	 *
	 * @return a List of DMIDs
	 */
	public List<String> getDmids() {
		return this.dmids;
	}

	/**
	 * Record a DMID if not already present.
	 *
	 * @param dmid the DMID to add
	 */
	public void addDmid(String dmid) {
		if (!this.dmids.contains(dmid)) {
			this.dmids.add(dmid);
		}
	}

	/**
	 * Build the <REPORT> XML element using the current status and message.
	 *
	 * @return XML fragment for the report element (no surrounding newlines)
	 */
	private String getReport() {
		String status = reportStatus ? "OK" : "FAILED";
		return "<REPORT status=\"" + status + "\">" + reportMessage + "</REPORT>";
	}

	/**
	 * Build the concatenated <MODEL/> entries from the models map.
	 *
	 * @return XML fragments for each model entry (may be empty if no models)
	 */
	private String getModels() {
		StringBuilder sb = new StringBuilder();
		for (Map.Entry<String, String> entry : models.entrySet()) {
			if (entry.getValue() != null && !entry.getValue().isEmpty()) {
				sb.append("<MODEL name=\"").append(entry.getKey()).append("\" url=\"").append(entry.getValue())
					.append("\" />\n");
			} else {
				sb.append("<MODEL name=\"").append(entry.getKey()).append("\" />\n");
			}
		}
		return sb.toString();
	}

	/**
	 * Wrap the collected globals fragments in a <GLOBALS> container.
	 *
	 * @return the full <GLOBALS> XML block (may contain only the open/close tags if
	 *         none)
	 */
	private String getGlobals() {
		StringBuilder sb = new StringBuilder("<GLOBALS>\n");
		for (String g : globals) {
			sb.append(g).append("\n");
		}
		sb.append("</GLOBALS>\n");
		return sb.toString();
	}

	/**
	 * Wrap the collected templates fragments in a <TEMPLATES> container and add a
	 * tableref attribute when templatesId is set.
	 *
	 * @return the full <TEMPLATES> XML block, or an empty string when no templates
	 */
	private String getTemplates() {
		if (templates.isEmpty())
			return "";

		StringBuilder sb = new StringBuilder();
		if (templatesId != null && !templatesId.isEmpty()) {
			sb.append("<TEMPLATES tableref=\"").append(templatesId).append("\">\n");
		} else {
			sb.append("<TEMPLATES>\n");
		}

		for (String t : templates) {
			sb.append(t).append("\n");
		}
		sb.append("</TEMPLATES>\n");
		return sb.toString();
	}

	/**
	 * Build a complete MIVOT block from all elements stored in the current instance.
	 *
	 * This method assembles REPORT, MODEL, GLOBALS and TEMPLATES sections and
	 * pretty-prints the resulting XML. If templatesId is provided it will be used
	 * as the tableref attribute for the TEMPLATES block; otherwise any previously
	 * set templatesId is used.
	 *
	 * @param templatesId ID of the mapped table (optional). If null, the current
	 *                    templatesId is preserved.
	 * @throws Exception on XML processing errors
	 */
	public void buildMivotBlock(String templatesId) throws Exception {
		if (templatesId != null) {
			this.templatesId = templatesId;
		}

		StringBuilder sb = new StringBuilder();
		sb.append("<VODML xmlns=\"http://www.ivoa.net/xml/mivot\">\n");
		sb.append(getReport()).append("\n");
		sb.append(getModels()).append("\n");
		sb.append(getGlobals()).append("\n");
		sb.append(getTemplates()).append("\n");
		sb.append("</VODML>");

		this.mivotBlock = XmlUtils.prettyString(sb.toString()).replaceAll("\n\\s*\n", "\n");
	}

	/**
	 * Add a MIVOT element into the TEMPLATES collection.
	 *
	 * Accepts either a {@link MivotInstance} (preferred) or a raw XML String.
	 * When a MivotInstance is provided its dmid (if present) is recorded to
	 * prevent duplicate IDs.
	 *
	 * @param instance MivotInstance or string serialization of an instance
	 * @throws Exception when the provided object is of an unsupported type
	 */
	public void addTemplates(Object instance) throws Exception {
		if (instance instanceof MivotInstance) {
			MivotInstance mi = (MivotInstance) instance;
			templates.add(mi.xmlString());
			if (mi.getDmid() != null)
				dmids.add(mi.getDmid());
		} else if (instance instanceof String) {
			templates.add((String) instance);
		} else {
			throw new Exception("Invalid type for templates instance: " + instance.getClass());
		}
	}

	/**
	 * Add a MIVOT element into the GLOBALS collection.
	 *
	 * Accepts either a {@link MivotInstance} or a raw XML String. When a
	 * MivotInstance is provided its dmid (if present) is recorded to prevent
	 * duplicate IDs.
	 *
	 * @param instance MivotInstance or string serialization of an instance
	 * @throws Exception when the provided object is of an unsupported type
	 */
	public void addGlobals(Object instance) throws Exception {
		if (instance instanceof MivotInstance) {
			MivotInstance mi = (MivotInstance) instance;
			globals.add(mi.xmlString());
			if (mi.getDmid() != null)
				dmids.add(mi.getDmid());
		} else if (instance instanceof String) {
			globals.add((String) instance);
		} else {
			throw new Exception("Invalid type for globals instance");
		}
	}

	/**
	 * Add a <MODEL> element
	 *
	 * @param name model name, this used as VODML prefix
	 * @param url  points on the model VODML file
	 */
	public void addModel(String name, String url) {
		models.put(name, url);
	}

	/**
	 * Set the mapping/report status and message.
	 *
	 * If status is false, GLOBALS and TEMPLATES collections are cleared to avoid
	 * publishing invalid mappings. Implementations may want to add logging when
	 * failures occur to help diagnosis.
	 *
	 * @param status  mapping status (true = OK, false = FAILED)
	 * @param message human-readable report message (free text)
	 */
	public void setReport(boolean status, String message) {
		this.reportStatus = status;
		this.reportMessage = message;
		if (!status) {
			globals.clear();
			templates.clear();
		}
	}

	/**
	 * Map database columns to a MANGO/MIVOT annotation and return the assembled
	 * RESOURCE meta block.
	 *
	 * Process overview:
	 * - Query the MappingCache for relevant utype-to-column mappings per table.
	 * - Build a MangoInstance populated with mapped Property objects and
	 *   corresponding frame GLOBALS sections.
	 * - Add necessary MODEL declarations and the generated MangoInstance to
	 *   the TEMPLATES collection, then build the final MIVOT block.
	 *
	 * This method catches internal exceptions, sets the report status to
	 * FAILED on errors and returns a RESOURCE element containing the report
	 * (instead of propagating the exception).
	 *
	 * @param columns map of table name -> set of column names available for mapping
	 * @return String containing a <RESOURCE type="meta"> wrapper with the generated
	 *         MIVOT block
	 */
	public String mapMango(Map<String, Set<String>> columns) {
		MappingCache MAPPING_CACHE = MappingCache.getCache();
		// Build the annotations
		MivotAnnotations mivotAnnotation = new MivotAnnotations();

		// Build the MANGO instance with the column used as identifier

		MangoInstance mi;
		try {
			String utypeMappedColumn = null;
			for (String table : columns.keySet()) {
				utypeMappedColumn = MAPPING_CACHE.getUtypeMappedColumn(table, "mango:MangoObject.identifier",
					new ArrayList<String>(columns.get(table)));
				if (utypeMappedColumn != null) {
					break;
				}
			}
			mi = new MangoInstance(utypeMappedColumn);
			FrameFactory frameFactory = FrameFactory.getInstance(this.sessionCache);
			for (String supportedProperty : Glossary.SUPPORTED_PROPERTIES) {
				// Look for mapping rules for the property in the current table
				Cache.logDebug("Looking at property: ", supportedProperty);
				for (String table : columns.keySet()) {
					List<String>selectedColumns =new ArrayList<String>(columns.get(table));
					Cache.logDebug(" Check if table: ", table, selectedColumns.toString(), "maps it");

					Map<String, List<UtypeDecoder>> propertyMapping = MAPPING_CACHE.getTableMapping(
						table,
						"mango:" + supportedProperty,
						selectedColumns);
					List<String> constants = new ArrayList<String>();
					for (String key : propertyMapping.keySet()) {
						Cache.logDebug("Found mapping for property ",supportedProperty ,"in table",
								table, "with key", key);
						List<FrameHolder> frameHolders = new ArrayList<>();
						List<UtypeDecoder> utds = propertyMapping.get(key);
						for (String cs : utds.get(0).getFrames()) {
							FrameHolder fh = frameFactory.createFrame(cs);
							frameHolders.add(fh);
							mivotAnnotation.addGlobals(fh.frameXml);
						}
						for (String ct : utds.get(0).getConstants()) {
							constants.add(ct);
						}
						Property property = (Property) Property.getInstance(supportedProperty, utds, table,
								frameHolders, constants);
						mi.addMangoProperties(property);
					}
				}
			}

			mivotAnnotation.addModel(Glossary.ModelPrefix.IVOA, Glossary.VodmlUrl.IVOA);
			mivotAnnotation.addModel(Glossary.ModelPrefix.MANGO, Glossary.VodmlUrl.MANGO);
			for (String model : this.sessionCache.getReferencedModelList() ) {
				mivotAnnotation.addModel(model, this.sessionCache.getReferencedModel(model));
			}

			mivotAnnotation.addTemplates(mi);

			mivotAnnotation.buildMivotBlock("");
			mivotAnnotation.setReport(true, "Annotated by vollt-mivot-extension");
		} catch (Exception exception) {
			exception.printStackTrace();
			mivotAnnotation.setReport(false, "Annotation failure: " + exception);
		}
		return "<RESOURCE type=\"meta\">\n" + mivotAnnotation.mivotBlock + "\n</RESOURCE>\n";	
	}
}